{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar isPlainObject = require('is-plain-object');\n\nvar React = require('react');\n\nvar prettyPrintObject = require('@base2/pretty-print-object');\n\nvar reactIs = require('react-is');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\nvar spacer = function (times, tabStop) {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction safeSortObject(value, seen) {\n  // return non-object value as is\n  if (value === null || _typeof(value) !== 'object') {\n    return value;\n  } // return date, regexp and react element values as is\n\n\n  if (value instanceof Date || value instanceof RegExp || /*#__PURE__*/React__namespace.isValidElement(value)) {\n    return value;\n  }\n\n  seen.add(value); // make a copy of array with each item passed through the sorting algorithm\n\n  if (Array.isArray(value)) {\n    return value.map(function (v) {\n      return safeSortObject(v, seen);\n    });\n  } // make a copy of object with key sorted\n\n\n  return Object.keys(value).sort().reduce(function (result, key) {\n    if (key === '_owner') {\n      return result;\n    }\n\n    if (key === 'current' || seen.has(value[key])) {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = '[Circular]';\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = safeSortObject(value[key], seen);\n    }\n\n    return result;\n  }, {});\n}\n\nfunction sortObject(value) {\n  return safeSortObject(value, new WeakSet());\n}\n/* eslint-disable no-use-before-define */\n\n\nvar createStringTreeNode = function createStringTreeNode(value) {\n  return {\n    type: 'string',\n    value: value\n  };\n};\n\nvar createNumberTreeNode = function createNumberTreeNode(value) {\n  return {\n    type: 'number',\n    value: value\n  };\n};\n\nvar createReactElementTreeNode = function createReactElementTreeNode(displayName, props, defaultProps, childrens) {\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: defaultProps,\n    childrens: childrens\n  };\n};\n\nvar createReactFragmentTreeNode = function createReactFragmentTreeNode(key, childrens) {\n  return {\n    type: 'ReactFragment',\n    key: key,\n    childrens: childrens\n  };\n};\n\nvar supportFragment = Boolean(React.Fragment);\n\nvar getFunctionTypeName = function getFunctionTypeName(functionType) {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n\n  return functionType.name;\n};\n\nvar getWrappedComponentDisplayName = function getWrappedComponentDisplayName(Component) {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n\n    case Component.$$typeof === reactIs.Memo:\n      return getWrappedComponentDisplayName(Component.type);\n\n    case Component.$$typeof === reactIs.ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n\n    default:\n      return getFunctionTypeName(Component);\n  }\n}; // heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\n\n\nvar getReactElementDisplayName = function getReactElementDisplayName(element) {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n\n      return getFunctionTypeName(element.type);\n\n    case reactIs.isForwardRef(element):\n    case reactIs.isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n\n    case reactIs.isContextConsumer(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Consumer\");\n\n    case reactIs.isContextProvider(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Provider\");\n\n    case reactIs.isLazy(element):\n      return 'Lazy';\n\n    case reactIs.isProfiler(element):\n      return 'Profiler';\n\n    case reactIs.isStrictMode(element):\n      return 'StrictMode';\n\n    case reactIs.isSuspense(element):\n      return 'Suspense';\n\n    default:\n      return 'UnknownElementType';\n  }\n};\n\nvar noChildren = function noChildren(propsValue, propName) {\n  return propName !== 'children';\n};\n\nvar onlyMeaningfulChildren = function onlyMeaningfulChildren(children) {\n  return children !== true && children !== false && children !== null && children !== '';\n};\n\nvar filterProps = function filterProps(originalProps, cb) {\n  var filteredProps = {};\n  Object.keys(originalProps).filter(function (key) {\n    return cb(originalProps[key], key);\n  }).forEach(function (key) {\n    return filteredProps[key] = originalProps[key];\n  });\n  return filteredProps;\n};\n\nvar parseReactElement = function parseReactElement(element, options) {\n  var _options$displayName = options.displayName,\n      displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (! /*#__PURE__*/React__default[\"default\"].isValidElement(element)) {\n    throw new Error(\"react-element-to-jsx-string: Expected a React.Element, got `\".concat(_typeof(element), \"`\"));\n  }\n\n  var displayName = displayNameFn(element);\n  var props = filterProps(element.props, noChildren);\n\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  var key = element.key;\n\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  var childrens = React__default[\"default\"].Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function (child) {\n    return parseReactElement(child, options);\n  });\n\n  if (supportFragment && element.type === React.Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(displayName, props, defaultProps, childrens);\n};\n\nfunction noRefCheck() {}\n\nvar inlineFunction = function inlineFunction(fn) {\n  return fn.toString().split('\\n').map(function (line) {\n    return line.trim();\n  }).join('');\n};\n\nvar preserveFunctionLineBreak = function preserveFunctionLineBreak(fn) {\n  return fn.toString();\n};\n\nvar defaultFunctionValue = inlineFunction;\n\nvar formatFunction = function (fn, options) {\n  var _options$functionValu = options.functionValue,\n      functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu,\n      showFunctions = options.showFunctions;\n\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n\nvar formatComplexDataStructure = function (value, inline, lvl, options) {\n  var normalizedValue = sortObject(value);\n  var stringifiedValue = prettyPrintObject.prettyPrint(normalizedValue, {\n    transform: function transform(currentObj, prop, originalResult) {\n      var currentValue = currentObj[prop];\n\n      if (currentValue && /*#__PURE__*/React.isValidElement(currentValue)) {\n        return formatTreeNode(parseReactElement(currentValue, options), true, lvl, options);\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    }\n  });\n\n  if (inline) {\n    return stringifiedValue.replace(/\\s+/g, ' ').replace(/{ /g, '{').replace(/ }/g, '}').replace(/\\[ /g, '[').replace(/ ]/g, ']');\n  } // Replace tabs with spaces, and add necessary indentation in front of each new line\n\n\n  return stringifiedValue.replace(/\\t/g, spacer(1, options.tabStop)).replace(/\\n([^$])/g, \"\\n\".concat(spacer(lvl + 1, options.tabStop), \"$1\"));\n};\n\nvar escape$1 = function escape(s) {\n  return s.replace(/\"/g, '&quot;');\n};\n\nvar formatPropValue = function formatPropValue(propValue, inline, lvl, options) {\n  if (typeof propValue === 'number') {\n    return \"{\".concat(String(propValue), \"}\");\n  }\n\n  if (typeof propValue === 'string') {\n    return \"\\\"\".concat(escape$1(propValue), \"\\\"\");\n  } // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n\n\n  if (_typeof(propValue) === 'symbol') {\n    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return \"{Symbol()}\";\n    }\n\n    return \"{Symbol('\".concat(symbolDescription, \"')}\");\n  }\n\n  if (typeof propValue === 'function') {\n    return \"{\".concat(formatFunction(propValue, options), \"}\");\n  }\n\n  if ( /*#__PURE__*/React.isValidElement(propValue)) {\n    return \"{\".concat(formatTreeNode(parseReactElement(propValue, options), true, lvl, options), \"}\");\n  }\n\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return \"{new Date(NaN)}\";\n    }\n\n    return \"{new Date(\\\"\".concat(propValue.toISOString(), \"\\\")}\");\n  }\n\n  if (isPlainObject.isPlainObject(propValue) || Array.isArray(propValue)) {\n    return \"{\".concat(formatComplexDataStructure(propValue, inline, lvl, options), \"}\");\n  }\n\n  return \"{\".concat(String(propValue), \"}\");\n};\n\nvar formatProp = function (name, hasValue, value, hasDefaultValue, defaultValue, inline, lvl, options) {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\"The prop \\\"\".concat(name, \"\\\" has no value and no default: could not be formatted\"));\n  }\n\n  var usedValue = hasValue ? value : defaultValue;\n  var useBooleanShorthandSyntax = options.useBooleanShorthandSyntax,\n      tabStop = options.tabStop;\n  var formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n  var attributeFormattedInline = ' ';\n  var attributeFormattedMultiline = \"\\n\".concat(spacer(lvl + 1, tabStop));\n  var isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (useBooleanShorthandSyntax && formattedPropValue === '{false}' && !hasDefaultValue) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += \"\".concat(name);\n    attributeFormattedMultiline += \"\".concat(name);\n  } else {\n    attributeFormattedInline += \"\".concat(name, \"=\").concat(formattedPropValue);\n    attributeFormattedMultiline += \"\".concat(name, \"=\").concat(formattedPropValue);\n  }\n\n  return {\n    attributeFormattedInline: attributeFormattedInline,\n    attributeFormattedMultiline: attributeFormattedMultiline,\n    isMultilineAttribute: isMultilineAttribute\n  };\n};\n\nvar mergeSiblingPlainStringChildrenReducer = function (previousNodes, currentNode) {\n  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0);\n  var previousNode = previousNodes[previousNodes.length - 1];\n\n  if (previousNode && (currentNode.type === 'string' || currentNode.type === 'number') && (previousNode.type === 'string' || previousNode.type === 'number')) {\n    nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value)));\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n\nvar isKeyOrRefProps = function isKeyOrRefProps(propName) {\n  return ['key', 'ref'].includes(propName);\n};\n\nvar sortPropsByNames = function (shouldSortUserProps) {\n  return function (props) {\n    var haveKeyProp = props.includes('key');\n    var haveRefProp = props.includes('ref');\n    var userPropsOnly = props.filter(function (oneProp) {\n      return !isKeyOrRefProps(oneProp);\n    });\n    var sortedProps = shouldSortUserProps ? _toConsumableArray(userPropsOnly.sort()) // We use basic lexical order\n    : _toConsumableArray(userPropsOnly);\n\n    if (haveRefProp) {\n      sortedProps.unshift('ref');\n    }\n\n    if (haveKeyProp) {\n      sortedProps.unshift('key');\n    }\n\n    return sortedProps;\n  };\n};\n\nfunction createPropFilter(props, filter) {\n  if (Array.isArray(filter)) {\n    return function (key) {\n      return filter.indexOf(key) === -1;\n    };\n  } else {\n    return function (key) {\n      return filter(props[key], key);\n    };\n  }\n}\n\nvar compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation(element, formattedElement, inline, lvl, options) {\n  var tabStop = options.tabStop;\n\n  if (element.type === 'string') {\n    return formattedElement.split('\\n').map(function (line, offset) {\n      if (offset === 0) {\n        return line;\n      }\n\n      return \"\".concat(spacer(lvl, tabStop)).concat(line);\n    }).join('\\n');\n  }\n\n  return formattedElement;\n};\n\nvar formatOneChildren = function formatOneChildren(inline, lvl, options) {\n  return function (element) {\n    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline, lvl, options), inline, lvl, options);\n  };\n};\n\nvar onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue(defaultProps, props) {\n  return function (propName) {\n    var haveDefaultValue = Object.keys(defaultProps).includes(propName);\n    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];\n  };\n};\n\nvar isInlineAttributeTooLong = function isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;\n};\n\nvar shouldRenderMultilineAttr = function shouldRenderMultilineAttr(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {\n  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;\n};\n\nvar formatReactElementNode = function (node, inline, lvl, options) {\n  var type = node.type,\n      _node$displayName = node.displayName,\n      displayName = _node$displayName === void 0 ? '' : _node$displayName,\n      childrens = node.childrens,\n      _node$props = node.props,\n      props = _node$props === void 0 ? {} : _node$props,\n      _node$defaultProps = node.defaultProps,\n      defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\"The \\\"formatReactElementNode\\\" function could only format node of type \\\"ReactElement\\\". Given:  \".concat(type));\n  }\n\n  var filterProps = options.filterProps,\n      maxInlineAttributesLineLength = options.maxInlineAttributesLineLength,\n      showDefaultProps = options.showDefaultProps,\n      sortProps = options.sortProps,\n      tabStop = options.tabStop;\n  var out = \"<\".concat(displayName);\n  var outInlineAttr = out;\n  var outMultilineAttr = out;\n  var containsMultilineAttr = false;\n  var visibleAttributeNames = [];\n  var propFilter = createPropFilter(props, filterProps);\n  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function (propName) {\n    return visibleAttributeNames.push(propName);\n  });\n  Object.keys(defaultProps).filter(propFilter).filter(function () {\n    return showDefaultProps;\n  }).filter(function (defaultPropName) {\n    return !visibleAttributeNames.includes(defaultPropName);\n  }).forEach(function (defaultPropName) {\n    return visibleAttributeNames.push(defaultPropName);\n  });\n  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n  attributes.forEach(function (attributeName) {\n    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options),\n        attributeFormattedInline = _formatProp.attributeFormattedInline,\n        attributeFormattedMultiline = _formatProp.attributeFormattedMultiline,\n        isMultilineAttribute = _formatProp.isMultilineAttribute;\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n  outMultilineAttr += \"\\n\".concat(spacer(lvl, tabStop));\n\n  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    var newLvl = lvl + 1;\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? \"\\n\".concat(spacer(newLvl, tabStop)) : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n\n    out += \"</\".concat(displayName, \">\");\n  } else {\n    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n\nvar REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nvar REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nvar toReactElementTreeNode = function toReactElementTreeNode(displayName, key, childrens) {\n  var props = {};\n\n  if (key) {\n    props = {\n      key: key\n    };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: {},\n    childrens: childrens\n  };\n};\n\nvar isKeyedFragment = function isKeyedFragment(_ref) {\n  var key = _ref.key;\n  return Boolean(key);\n};\n\nvar hasNoChildren = function hasNoChildren(_ref2) {\n  var childrens = _ref2.childrens;\n  return childrens.length === 0;\n};\n\nvar formatReactFragmentNode = function (node, inline, lvl, options) {\n  var type = node.type,\n      key = node.key,\n      childrens = node.childrens;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\"The \\\"formatReactFragmentNode\\\" function could only format node of type \\\"ReactFragment\\\". Given: \".concat(type));\n  }\n\n  var useFragmentShortSyntax = options.useFragmentShortSyntax;\n  var displayName;\n\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline, lvl, options);\n};\n\nvar jsxStopChars = ['<', '>', '{', '}'];\n\nvar shouldBeEscaped = function shouldBeEscaped(s) {\n  return jsxStopChars.some(function (jsxStopChar) {\n    return s.includes(jsxStopChar);\n  });\n};\n\nvar escape = function escape(s) {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return \"{`\".concat(s, \"`}\");\n};\n\nvar preserveTrailingSpace = function preserveTrailingSpace(s) {\n  var result = s;\n\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nvar formatTreeNode = function (node, inline, lvl, options) {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value ? \"\".concat(preserveTrailingSpace(escape(String(node.value)))) : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(\"Unknow format type \\\"\".concat(node.type, \"\\\"\"));\n};\n\nvar formatTree = function (node, options) {\n  return formatTreeNode(node, false, 0, options);\n};\n\nvar reactElementToJsxString = function reactElementToJsxString(element) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$filterProps = _ref.filterProps,\n      filterProps = _ref$filterProps === void 0 ? [] : _ref$filterProps,\n      _ref$showDefaultProps = _ref.showDefaultProps,\n      showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps,\n      _ref$showFunctions = _ref.showFunctions,\n      showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions,\n      functionValue = _ref.functionValue,\n      _ref$tabStop = _ref.tabStop,\n      tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop,\n      _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax,\n      useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth,\n      _ref$useFragmentShort = _ref.useFragmentShortSyntax,\n      useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort,\n      _ref$sortProps = _ref.sortProps,\n      sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps,\n      maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength,\n      displayName = _ref.displayName;\n\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  var options = {\n    filterProps: filterProps,\n    showDefaultProps: showDefaultProps,\n    showFunctions: showFunctions,\n    functionValue: functionValue,\n    tabStop: tabStop,\n    useBooleanShorthandSyntax: useBooleanShorthandSyntax,\n    useFragmentShortSyntax: useFragmentShortSyntax,\n    sortProps: sortProps,\n    maxInlineAttributesLineLength: maxInlineAttributesLineLength,\n    displayName: displayName\n  };\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexports[\"default\"] = reactElementToJsxString;\nexports.inlineFunction = inlineFunction;\nexports.preserveFunctionLineBreak = preserveFunctionLineBreak;","map":{"version":3,"sources":["../../src/formatter/spacer.js","../../src/formatter/sortObject.js","../../src/tree.js","../../src/parser/parseReactElement.js","../../src/formatter/formatFunction.js","../../src/formatter/formatComplexDataStructure.js","../../src/formatter/formatPropValue.js","../../src/formatter/formatProp.js","../../src/formatter/mergeSiblingPlainStringChildrenReducer.js","../../src/formatter/sortPropsByNames.js","../../src/formatter/createPropFilter.js","../../src/formatter/formatReactElementNode.js","../../src/formatter/formatReactFragmentNode.js","../../src/formatter/formatTreeNode.js","../../src/formatter/formatTree.js","../../src/index.js"],"names":["times","value","React","seen","Array","safeSortObject","key","result","createStringTreeNode","type","createNumberTreeNode","createReactElementTreeNode","displayName","props","defaultProps","childrens","createReactFragmentTreeNode","supportFragment","Boolean","Fragment","getFunctionTypeName","functionType","getWrappedComponentDisplayName","Component","Memo","ForwardRef","getReactElementDisplayName","element","isForwardRef","isMemo","isContextConsumer","isContextProvider","isLazy","isProfiler","isStrictMode","isSuspense","noChildren","propName","onlyMeaningfulChildren","children","filterProps","filteredProps","Object","cb","originalProps","parseReactElement","displayNameFn","options","inlineFunction","fn","line","preserveFunctionLineBreak","defaultFunctionValue","functionValue","showFunctions","normalizedValue","sortObject","stringifiedValue","prettyPrint","transform","currentObj","currentValue","isValidElement","formatTreeNode","formatFunction","spacer","lvl","escape","s","formatPropValue","String","propValue","symbolDescription","isNaN","isPlainObject","formatComplexDataStructure","name","usedValue","hasValue","useBooleanShorthandSyntax","tabStop","formattedPropValue","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","nodes","previousNodes","previousNode","currentNode","isKeyOrRefProps","haveKeyProp","haveRefProp","userPropsOnly","sortedProps","shouldSortUserProps","filter","compensateMultilineStringElementIndentation","offset","formatOneChildren","onlyPropsWithOriginalValue","haveDefaultValue","isInlineAttributeTooLong","attributes","inlineAttributeString","shouldRenderMultilineAttr","node","maxInlineAttributesLineLength","showDefaultProps","sortProps","out","outInlineAttr","outMultilineAttr","containsMultilineAttr","visibleAttributeNames","propFilter","createPropFilter","sortPropsByNames","formatProp","newLvl","REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX","REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX","toReactElementTreeNode","isKeyedFragment","hasNoChildren","useFragmentShortSyntax","formatReactElementNode","jsxStopChars","shouldBeEscaped","preserveTrailingSpace","formatReactFragmentNode","reactElementToJsxString","formatTree"],"mappings":"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","sourcesContent":["/* @flow */\n\nexport default (times: number, tabStop: number): string => {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n","/* @flow */\nimport * as React from 'react';\n\nfunction safeSortObject(value: any, seen: WeakSet<any>): any {\n  // return non-object value as is\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // return date, regexp and react element values as is\n  if (\n    value instanceof Date ||\n    value instanceof RegExp ||\n    React.isValidElement(value)\n  ) {\n    return value;\n  }\n\n  seen.add(value);\n\n  // make a copy of array with each item passed through the sorting algorithm\n  if (Array.isArray(value)) {\n    return value.map(v => safeSortObject(v, seen));\n  }\n\n  // make a copy of object with key sorted\n  return Object.keys(value)\n    .sort()\n    .reduce((result, key) => {\n      if (key === '_owner') {\n        return result;\n      }\n      if (key === 'current' || seen.has(value[key])) {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = '[Circular]';\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = safeSortObject(value[key], seen);\n      }\n      return result;\n    }, {});\n}\n\nexport default function sortObject(value: any): any {\n  return safeSortObject(value, new WeakSet());\n}\n","/* @flow */\n/* eslint-disable no-use-before-define */\n\nimport type { Key } from 'react';\n\ntype PropsType = { [key: string]: any };\ntype DefaultPropsType = { [key: string]: any };\n\nexport type StringTreeNode = {|\n  type: 'string',\n  value: string,\n|};\n\nexport type NumberTreeNode = {|\n  type: 'number',\n  value: number,\n|};\n\nexport type ReactElementTreeNode = {|\n  type: 'ReactElement',\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[],\n|};\n\nexport type ReactFragmentTreeNode = {|\n  type: 'ReactFragment',\n  key: ?Key,\n  childrens: TreeNode[],\n|};\n\nexport type TreeNode =\n  | StringTreeNode\n  | NumberTreeNode\n  | ReactElementTreeNode\n  | ReactFragmentTreeNode;\n\nexport const createStringTreeNode = (value: string): StringTreeNode => ({\n  type: 'string',\n  value,\n});\n\nexport const createNumberTreeNode = (value: number): NumberTreeNode => ({\n  type: 'number',\n  value,\n});\n\nexport const createReactElementTreeNode = (\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[]\n): ReactElementTreeNode => ({\n  type: 'ReactElement',\n  displayName,\n  props,\n  defaultProps,\n  childrens,\n});\n\nexport const createReactFragmentTreeNode = (\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactFragmentTreeNode => ({\n  type: 'ReactFragment',\n  key,\n  childrens,\n});\n","/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport {\n  ForwardRef,\n  isContextConsumer,\n  isContextProvider,\n  isForwardRef,\n  isLazy,\n  isMemo,\n  isProfiler,\n  isStrictMode,\n  isSuspense,\n  Memo,\n} from 'react-is';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getFunctionTypeName = (functionType): string => {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n  return functionType.name;\n};\n\nconst getWrappedComponentDisplayName = (Component: *): string => {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n    case Component.$$typeof === Memo:\n      return getWrappedComponentDisplayName(Component.type);\n    case Component.$$typeof === ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n    default:\n      return getFunctionTypeName(Component);\n  }\n};\n\n// heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\nconst getReactElementDisplayName = (element: ReactElement<*>): string => {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n      return getFunctionTypeName(element.type);\n    case isForwardRef(element):\n    case isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n    case isContextConsumer(element):\n      return `${element.type._context.displayName || 'Context'}.Consumer`;\n    case isContextProvider(element):\n      return `${element.type._context.displayName || 'Context'}.Provider`;\n    case isLazy(element):\n      return 'Lazy';\n    case isProfiler(element):\n      return 'Profiler';\n    case isStrictMode(element):\n      return 'StrictMode';\n    case isSuspense(element):\n      return 'Suspense';\n    default:\n      return 'UnknownElementType';\n  }\n};\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n","import type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport const inlineFunction = (fn: any): string =>\n  fn\n    .toString()\n    .split('\\n')\n    .map(line => line.trim())\n    .join('');\n\nexport const preserveFunctionLineBreak = (fn: any): string => fn.toString();\n\nconst defaultFunctionValue = inlineFunction;\n\nexport default (fn: Function, options: Options): string => {\n  const { functionValue = defaultFunctionValue, showFunctions } = options;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n","/* @flow */\n\nimport { isValidElement } from 'react';\nimport { prettyPrint } from '@base2/pretty-print-object';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport formatFunction from './formatFunction';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = prettyPrint(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n","/* @flow */\n\nimport { isPlainObject } from 'is-plain-object';\nimport { isValidElement } from 'react';\nimport formatComplexDataStructure from './formatComplexDataStructure';\nimport formatFunction from './formatFunction';\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport parseReactElement from './../parser/parseReactElement';\n\nconst escape = (s: string): string => s.replace(/\"/g, '&quot;');\n\nconst formatPropValue = (\n  propValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (typeof propValue === 'number') {\n    return `{${String(propValue)}}`;\n  }\n\n  if (typeof propValue === 'string') {\n    return `\"${escape(propValue)}\"`;\n  }\n\n  // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n  if (typeof propValue === 'symbol') {\n    const symbolDescription = propValue\n      .valueOf()\n      .toString()\n      .replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return `{Symbol()}`;\n    }\n\n    return `{Symbol('${symbolDescription}')}`;\n  }\n\n  if (typeof propValue === 'function') {\n    return `{${formatFunction(propValue, options)}}`;\n  }\n\n  if (isValidElement(propValue)) {\n    return `{${formatTreeNode(\n      parseReactElement(propValue, options),\n      true,\n      lvl,\n      options\n    )}}`;\n  }\n\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return `{new Date(NaN)}`;\n    }\n    return `{new Date(\"${propValue.toISOString()}\")}`;\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return `{${formatComplexDataStructure(propValue, inline, lvl, options)}}`;\n  }\n\n  return `{${String(propValue)}}`;\n};\n\nexport default formatPropValue;\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatPropValue from './formatPropValue';\nimport type { Options } from './../options';\n\nexport default (\n  name: string,\n  hasValue: boolean,\n  value: any,\n  hasDefaultValue: boolean,\n  defaultValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): {\n  attributeFormattedInline: string,\n  attributeFormattedMultiline: string,\n  isMultilineAttribute: boolean,\n} => {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\n      `The prop \"${name}\" has no value and no default: could not be formatted`\n    );\n  }\n\n  const usedValue = hasValue ? value : defaultValue;\n\n  const { useBooleanShorthandSyntax, tabStop } = options;\n\n  const formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n\n  let attributeFormattedInline = ' ';\n  let attributeFormattedMultiline = `\\n${spacer(lvl + 1, tabStop)}`;\n  const isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (\n    useBooleanShorthandSyntax &&\n    formattedPropValue === '{false}' &&\n    !hasDefaultValue\n  ) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += `${name}`;\n    attributeFormattedMultiline += `${name}`;\n  } else {\n    attributeFormattedInline += `${name}=${formattedPropValue}`;\n    attributeFormattedMultiline += `${name}=${formattedPropValue}`;\n  }\n\n  return {\n    attributeFormattedInline,\n    attributeFormattedMultiline,\n    isMultilineAttribute,\n  };\n};\n","/* @flow */\n\nimport { createStringTreeNode } from './../tree';\nimport type { TreeNode } from './../tree';\n\nexport default (\n  previousNodes: TreeNode[],\n  currentNode: TreeNode\n): TreeNode[] => {\n  const nodes = previousNodes.slice(\n    0,\n    previousNodes.length > 0 ? previousNodes.length - 1 : 0\n  );\n  const previousNode = previousNodes[previousNodes.length - 1];\n\n  if (\n    previousNode &&\n    (currentNode.type === 'string' || currentNode.type === 'number') &&\n    (previousNode.type === 'string' || previousNode.type === 'number')\n  ) {\n    nodes.push(\n      createStringTreeNode(\n        String(previousNode.value) + String(currentNode.value)\n      )\n    );\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n","/* @flow */\n\nconst isKeyOrRefProps = (propName: string) => ['key', 'ref'].includes(propName);\n\nexport default (shouldSortUserProps: boolean) => (\n  props: string[]\n): string[] => {\n  const haveKeyProp = props.includes('key');\n  const haveRefProp = props.includes('ref');\n\n  const userPropsOnly = props.filter(oneProp => !isKeyOrRefProps(oneProp));\n\n  const sortedProps = shouldSortUserProps\n    ? [...userPropsOnly.sort()] // We use basic lexical order\n    : [...userPropsOnly];\n\n  if (haveRefProp) {\n    sortedProps.unshift('ref');\n  }\n\n  if (haveKeyProp) {\n    sortedProps.unshift('key');\n  }\n\n  return sortedProps;\n};\n","/* @flow */\n\nexport default function createPropFilter(\n  props: {},\n  filter: string[] | ((any, string) => boolean)\n) {\n  if (Array.isArray(filter)) {\n    return (key: string) => filter.indexOf(key) === -1;\n  } else {\n    return (key: string) => filter(props[key], key);\n  }\n}\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport sortPropsByNames from './sortPropsByNames';\nimport createPropFilter from './createPropFilter';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${type}`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  const propFilter = createPropFilter(props, filterProps);\n\n  Object.keys(props)\n    .filter(propFilter)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(propFilter)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n","/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${type}`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n","/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n","/* @flow */\n\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nexport default (node: TreeNode, options: Options): string =>\n  formatTreeNode(node, false, 0, options);\n","/* @flow */\n\nimport formatTree from './formatter/formatTree';\nimport parseReactElement from './parser/parseReactElement';\nimport type { Element as ReactElement } from 'react';\nimport type { Options } from './options';\n\nconst reactElementToJsxString = (\n  element: ReactElement<any>,\n  {\n    filterProps = [],\n    showDefaultProps = true,\n    showFunctions = false,\n    functionValue,\n    tabStop = 2,\n    useBooleanShorthandSyntax = true,\n    useFragmentShortSyntax = true,\n    sortProps = true,\n    maxInlineAttributesLineLength,\n    displayName,\n  }: Options = {}\n) => {\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  const options = {\n    filterProps,\n    showDefaultProps,\n    showFunctions,\n    functionValue,\n    tabStop,\n    useBooleanShorthandSyntax,\n    useFragmentShortSyntax,\n    sortProps,\n    maxInlineAttributesLineLength,\n    displayName,\n  };\n\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexport default reactElementToJsxString;\n\nexport {\n  inlineFunction,\n  preserveFunctionLineBreak,\n} from './formatter/formatFunction';\n"]},"metadata":{},"sourceType":"script"}